// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;
struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};

struct ArgumentBufferGroup0 {
    metal::texture2d<float, metal::access::sample> t1_ [[id(0)]];
    metal::texture2d<float, metal::access::sample> t2_ [[id(1)]];
    metal::sampler s1_ [[id(2)]];
    metal::sampler s2_ [[id(3)]];
    constant metal::float2& uniformOne [[id(4)]];
};
struct ArgumentBufferGroup1 {
    constant metal::float2& uniformTwo [[id(0)]];
};

struct entry_point_oneInput {
};
struct entry_point_oneOutput {
    metal::float4 member [[color(0)]];
};
fragment entry_point_oneOutput entry_point_one(
  metal::float4 pos [[position]]
, device ArgumentBufferGroup0& argumentBufferGroup0 [[buffer(0)]]
) {
    constexpr metal::sampler s1_(
        metal::s_address::clamp_to_edge,
        metal::t_address::clamp_to_edge,
        metal::r_address::clamp_to_edge,
        metal::mag_filter::linear,
        metal::min_filter::linear,
        metal::coord::normalized
    );
    metal::float4 _e4 = argumentBufferGroup0.t1_.sample(argumentBufferGroup0.s1_, pos.xy);
    return entry_point_oneOutput { _e4 };
}


struct entry_point_twoOutput {
    metal::float4 member_1 [[color(0)]];
};
fragment entry_point_twoOutput entry_point_two(
  device ArgumentBufferGroup0& argumentBufferGroup0 [[buffer(0)]]
) {
    metal::float2 _e3 = argumentBufferGroup0.uniformOne;
    metal::float4 _e4 = argumentBufferGroup0.t1_.sample(argumentBufferGroup0.s1_, _e3);
    return entry_point_twoOutput { _e4 };
}


struct entry_point_threeOutput {
    metal::float4 member_2 [[color(0)]];
};
fragment entry_point_threeOutput entry_point_three(
  device ArgumentBufferGroup0& argumentBufferGroup0 [[buffer(0)]]
, device ArgumentBufferGroup1& argumentBufferGroup1 [[buffer(1)]]
) {
    constexpr metal::sampler s1_(
        metal::s_address::clamp_to_edge,
        metal::t_address::clamp_to_edge,
        metal::r_address::clamp_to_edge,
        metal::mag_filter::linear,
        metal::min_filter::linear,
        metal::coord::normalized
    );
    metal::float2 _e3 = argumentBufferGroup1.uniformTwo;
    metal::float2 _e5 = argumentBufferGroup0.uniformOne;
    metal::float4 _e7 = argumentBufferGroup0.t1_.sample(argumentBufferGroup0.s1_, _e3 + _e5);
    metal::float2 _e11 = argumentBufferGroup0.uniformOne;
    metal::float4 _e12 = argumentBufferGroup0.t2_.sample(argumentBufferGroup0.s2_, _e11);
    return entry_point_threeOutput { _e7 + _e12 };
}
