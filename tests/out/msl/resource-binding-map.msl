// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;
struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};


struct entry_point_oneInput {
};
struct entry_point_oneOutput {
    metal::float4 member [[color(0)]];
};
struct entry_point_oneArgumentBuffer {
    metal::texture2d<float, metal::access::sample> t1_ [[id(0)]];
    metal::sampler s1_ [[id(1)]];
};
fragment entry_point_oneOutput entry_point_one(
  metal::float4 pos [[position]]
, device entry_point_oneArgumentBuffer& argumentBuffer [[buffer(0)]]
) {
    constexpr metal::sampler s1_(
        metal::s_address::clamp_to_edge,
        metal::t_address::clamp_to_edge,
        metal::r_address::clamp_to_edge,
        metal::mag_filter::linear,
        metal::min_filter::linear,
        metal::coord::normalized
    );
    metal::float4 _e4 = argumentBuffer.t1_.sample(argumentBuffer.s1_, pos.xy);
    return entry_point_oneOutput { _e4 };
}


struct entry_point_twoOutput {
    metal::float4 member_1 [[color(0)]];
};
struct entry_point_twoArgumentBuffer {
    metal::texture2d<float, metal::access::sample> t1_ [[id(0)]];
    metal::sampler s1_ [[id(1)]];
    constant metal::float2& uniformOne [[id(2)]];
};
fragment entry_point_twoOutput entry_point_two(
  device entry_point_twoArgumentBuffer& argumentBuffer [[buffer(0)]]
) {
    metal::float2 _e3 = argumentBuffer.uniformOne;
    metal::float4 _e4 = argumentBuffer.t1_.sample(argumentBuffer.s1_, _e3);
    return entry_point_twoOutput { _e4 };
}


struct entry_point_threeOutput {
    metal::float4 member_2 [[color(0)]];
};
struct entry_point_threeArgumentBuffer {
    metal::texture2d<float, metal::access::sample> t1_ [[id(0)]];
    metal::texture2d<float, metal::access::sample> t2_ [[id(1)]];
    metal::sampler s1_ [[id(2)]];
    metal::sampler s2_ [[id(3)]];
    constant metal::float2& uniformOne [[id(4)]];
    constant metal::float2& uniformTwo [[id(5)]];
};
fragment entry_point_threeOutput entry_point_three(
  device entry_point_threeArgumentBuffer& argumentBuffer [[buffer(0)]]
) {
    constexpr metal::sampler s1_(
        metal::s_address::clamp_to_edge,
        metal::t_address::clamp_to_edge,
        metal::r_address::clamp_to_edge,
        metal::mag_filter::linear,
        metal::min_filter::linear,
        metal::coord::normalized
    );
    metal::float2 _e3 = argumentBuffer.uniformTwo;
    metal::float2 _e5 = argumentBuffer.uniformOne;
    metal::float4 _e7 = argumentBuffer.t1_.sample(argumentBuffer.s1_, _e3 + _e5);
    metal::float2 _e11 = argumentBuffer.uniformOne;
    metal::float4 _e12 = argumentBuffer.t2_.sample(argumentBuffer.s2_, _e11);
    return entry_point_threeOutput { _e7 + _e12 };
}
