// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size1;
};

typedef uint u32_;
typedef metal::uint3 vec3u32_;
typedef int i32_;
struct GlobalConst {
    u32_ a;
    char _pad1[12];
    metal::packed_uint3 b;
    i32_ c;
};
struct AlignedWrapper {
    i32_ value;
};
typedef metal::float4x3 mat4x3f32_;
typedef metal::float2x2 mat2x2f32_;
struct arraymat2x2f322_ {
    mat2x2f32_ inner[2u];
};
typedef metal::atomic_int atomici32_;
typedef metal::uint2 vec2u32_;
struct arrayvec2u322_ {
    vec2u32_ inner[2u];
};
typedef AlignedWrapper arrayAlignedWrapper[1];
struct Bar {
    mat4x3f32_ _matrix;
    arraymat2x2f322_ matrix_array;
    atomici32_ atom;
    char _pad3[4];
    arrayvec2u322_ arr;
    arrayAlignedWrapper data;
};
typedef metal::float3x2 mat3x2f32_;
struct Baz {
    mat3x2f32_ m;
};
typedef metal::int2 vec2i32_;
typedef constant Baz& ptruniformBaz;
typedef constant mat3x2f32_& ptruniformmat3x2f32_;
typedef constant metal::float2& ptruniformvec2f32_;
typedef float f32_;
typedef metal::float2 vec2f32_;
typedef thread Baz& ptrfunctionBaz;
typedef thread mat3x2f32_& ptrfunctionmat3x2f32_;
typedef thread metal::float2& ptrfunctionvec2f32_;
typedef metal::float4x2 mat4x2f32_;
struct arraymat4x2f322_ {
    mat4x2f32_ inner[2u];
};
struct MatCx2InArray {
    arraymat4x2f322_ am;
};
typedef constant MatCx2InArray& ptruniformMatCx2InArray;
typedef constant arraymat4x2f322_& ptruniformarraymat4x2f322_;
typedef constant mat4x2f32_& ptruniformmat4x2f32_;
typedef thread MatCx2InArray& ptrfunctionMatCx2InArray;
typedef thread arraymat4x2f322_& ptrfunctionarraymat4x2f322_;
typedef thread mat4x2f32_& ptrfunctionmat4x2f32_;
typedef thread f32_& ptrfunctionf32_;
struct arrayf3210_ {
    f32_ inner[10u];
};
struct arrayarrayf32105_ {
    arrayf3210_ inner[5u];
};
typedef metal::float4 vec4f32_;
typedef device Bar& ptrstorageBar;
typedef device mat4x3f32_& ptrstoragemat4x3f32_;
typedef device metal::float3& ptrstoragevec3f32_;
typedef metal::float3 vec3f32_;
typedef device arrayAlignedWrapper& ptrstoragearrayAlignedWrapper;
typedef device AlignedWrapper& ptrstorageAlignedWrapper;
typedef device i32_& ptrstoragei32_;
struct arrayi325_ {
    i32_ inner[5u];
};
typedef thread arrayi325_& ptrfunctionarrayi325_;
typedef metal::int4 vec4i32_;
typedef device atomici32_& ptrstorageatomici32_;
typedef threadgroup u32_& ptrworkgroupu32_;
constant vec3u32_ const_vec3u32_ = {0u, 0u, 0u};
constant GlobalConst const_GlobalConst = {0u, {}, const_vec3u32_, 0};
constant vec2f32_ const_vec2f32_ = {0.0, 0.0};
constant mat4x2f32_ const_mat4x2f32_ = {const_vec2f32_, const_vec2f32_, const_vec2f32_, const_vec2f32_};
constant arraymat4x2f322_ const_arraymat4x2f322_ = {const_mat4x2f32_, const_mat4x2f32_};
constant arrayf3210_ const_arrayf3210_ = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
constant arrayarrayf32105_ const_arrayarrayf32105_ = {const_arrayf3210_, const_arrayf3210_, const_arrayf3210_, const_arrayf3210_, const_arrayf3210_};
constant vec2i32_ const_vec2i32_ = {0, 0};

void test_matrix_within_struct_accesses(
    constant Baz& baz
) {
    i32_ idx = {};
    Baz t = {};
    idx = 1;
    i32_ _e3 = idx;
    idx = _e3 - 1;
    mat3x2f32_ unnamed = baz.m;
    metal::float2 unnamed_1 = baz.m[0];
    i32_ _e17 = idx;
    metal::float2 unnamed_2 = baz.m[_e17];
    float unnamed_3 = baz.m[0].y;
    i32_ _e32 = idx;
    float unnamed_4 = baz.m[0][_e32];
    i32_ _e38 = idx;
    float unnamed_5 = baz.m[_e38].y;
    i32_ _e46 = idx;
    i32_ _e49 = idx;
    float unnamed_6 = baz.m[_e46][_e49];
    Baz t_2 = Baz {metal::float3x2(metal::float2(1.0), metal::float2(2.0), metal::float2(3.0))};
    t = t_2;
    i32_ _e62 = idx;
    idx = _e62 + 1;
    t.m = metal::float3x2(metal::float2(6.0), metal::float2(5.0), metal::float2(4.0));
    t.m[0] = metal::float2(9.0);
    i32_ _e85 = idx;
    t.m[_e85] = metal::float2(90.0);
    t.m[0].y = 10.0;
    i32_ _e99 = idx;
    t.m[0][_e99] = 20.0;
    i32_ _e105 = idx;
    t.m[_e105].y = 30.0;
    i32_ _e113 = idx;
    i32_ _e116 = idx;
    t.m[_e113][_e116] = 40.0;
    return;
}

void test_matrix_within_array_within_struct_accesses(
    constant MatCx2InArray& nested_mat_cx2_
) {
    i32_ idx_1 = {};
    MatCx2InArray t_1 = {};
    idx_1 = 1;
    i32_ _e3 = idx_1;
    idx_1 = _e3 - 1;
    arraymat4x2f322_ unnamed_7 = nested_mat_cx2_.am;
    mat4x2f32_ unnamed_8 = nested_mat_cx2_.am.inner[0];
    metal::float2 unnamed_9 = nested_mat_cx2_.am.inner[0][0];
    i32_ _e26 = idx_1;
    metal::float2 unnamed_10 = nested_mat_cx2_.am.inner[0][_e26];
    float unnamed_11 = nested_mat_cx2_.am.inner[0][0].y;
    i32_ _e45 = idx_1;
    float unnamed_12 = nested_mat_cx2_.am.inner[0][0][_e45];
    i32_ _e53 = idx_1;
    float unnamed_13 = nested_mat_cx2_.am.inner[0][_e53].y;
    i32_ _e63 = idx_1;
    i32_ _e66 = idx_1;
    float unnamed_14 = nested_mat_cx2_.am.inner[0][_e63][_e66];
    MatCx2InArray t_3 = MatCx2InArray {const_arraymat4x2f322_};
    t_1 = t_3;
    i32_ _e73 = idx_1;
    idx_1 = _e73 + 1;
    for(int _i=0; _i<2; ++_i) t_1.am.inner[_i] = const_arraymat4x2f322_.inner[_i];
    t_1.am.inner[0] = metal::float4x2(metal::float2(8.0), metal::float2(7.0), metal::float2(6.0), metal::float2(5.0));
    t_1.am.inner[0][0] = metal::float2(9.0);
    i32_ _e107 = idx_1;
    t_1.am.inner[0][_e107] = metal::float2(90.0);
    t_1.am.inner[0][0].y = 10.0;
    i32_ _e125 = idx_1;
    t_1.am.inner[0][0][_e125] = 20.0;
    i32_ _e133 = idx_1;
    t_1.am.inner[0][_e133].y = 30.0;
    i32_ _e143 = idx_1;
    i32_ _e146 = idx_1;
    t_1.am.inner[0][_e143][_e146] = 40.0;
    return;
}

f32_ read_from_private(
    ptrfunctionf32_ foo_1
) {
    f32_ _e1 = foo_1;
    return _e1;
}

f32_ test_arr_as_arg(
    arrayarrayf32105_ a
) {
    return a.inner[4].inner[9];
}

void assign_through_ptr_fn(
    ptrworkgroupu32_ p
) {
    p = 42u;
    return;
}

struct foo_vertInput {
};
struct foo_vertOutput {
    metal::float4 member [[position]];
};
vertex foo_vertOutput foo_vert(
  u32_ vi [[vertex_id]]
, device Bar const& bar [[buffer(0)]]
, constant Baz& baz [[buffer(1)]]
, device vec2i32_ const& qux [[buffer(2)]]
, constant MatCx2InArray& nested_mat_cx2_ [[buffer(3)]]
, constant _mslBufferSizes& _buffer_sizes [[buffer(24)]]
) {
    f32_ foo = {};
    arrayi325_ d = {};
    foo = 0.0;
    f32_ baz_1 = foo;
    foo = 1.0;
    test_matrix_within_struct_accesses(baz);
    test_matrix_within_array_within_struct_accesses(nested_mat_cx2_);
    mat4x3f32_ _matrix = bar._matrix;
    arrayvec2u322_ arr = bar.arr;
    float b = bar._matrix[3].x;
    i32_ a_1 = bar.data[(1 + (_buffer_sizes.size1 - 120 - 8) / 8) - 2u].value;
    vec2i32_ c = qux;
    f32_ _e35 = read_from_private(foo);
    arrayi325_ d_1 = arrayi325_ {a_1, static_cast<int>(b), 3, 4, 5};
    for(int _i=0; _i<5; ++_i) d.inner[_i] = d_1.inner[_i];
    d.inner[vi + 1u] = 42;
    i32_ value = d.inner[vi];
    f32_ _e53 = test_arr_as_arg(const_arrayarrayf32105_);
    return foo_vertOutput { metal::float4(_matrix * static_cast<metal::float4>(metal::int4(value)), 2.0) };
}


struct foo_fragOutput {
    metal::float4 member_1 [[color(0)]];
};
fragment foo_fragOutput foo_frag(
  device Bar& bar [[buffer(0)]]
, device vec2i32_& qux [[buffer(2)]]
, constant _mslBufferSizes& _buffer_sizes [[buffer(24)]]
) {
    bar._matrix[1].z = 1.0;
    bar._matrix = metal::float4x3(metal::float3(0.0), metal::float3(1.0), metal::float3(2.0), metal::float3(3.0));
    for(int _i=0; _i<2; ++_i) bar.arr.inner[_i] = arrayvec2u322_ {metal::uint2(0u), metal::uint2(1u)}.inner[_i];
    bar.data[1].value = 1;
    qux = const_vec2i32_;
    return foo_fragOutput { metal::float4(0.0) };
}


kernel void atomics(
  device Bar& bar [[buffer(0)]]
, constant _mslBufferSizes& _buffer_sizes [[buffer(24)]]
) {
    i32_ tmp = {};
    int value_1 = metal::atomic_load_explicit(&bar.atom, metal::memory_order_relaxed);
    int _e6 = metal::atomic_fetch_add_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e6;
    int _e11 = metal::atomic_fetch_sub_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e11;
    int _e16 = metal::atomic_fetch_and_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e16;
    int _e21 = metal::atomic_fetch_or_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e21;
    int _e26 = metal::atomic_fetch_xor_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e26;
    int _e31 = metal::atomic_fetch_min_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e31;
    int _e36 = metal::atomic_fetch_max_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e36;
    int _e41 = metal::atomic_exchange_explicit(&bar.atom, 5, metal::memory_order_relaxed);
    tmp = _e41;
    metal::atomic_store_explicit(&bar.atom, value_1, metal::memory_order_relaxed);
    return;
}


kernel void assign_through_ptr(
  threadgroup u32_& val
) {
    assign_through_ptr_fn(val);
    return;
}
