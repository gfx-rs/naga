// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct FragmentOutput {
    metal::float4 vec4f;
    metal::int4 vec4i;
    metal::uint4 vec4u;
    metal::float3 vec3f;
    metal::int3 vec3i;
    metal::uint3 vec3u;
    metal::float2 vec2f;
    metal::int2 vec2i;
    metal::uint2 vec2u;
    float scalarf;
    int scalari;
    uint scalaru;
};

struct main_Output {
    metal::float4 vec4f [[color(0)]];
    metal::int4 vec4i [[color(1)]];
    metal::uint4 vec4u [[color(2)]];
    metal::float3 vec3f [[color(3)]];
    metal::int3 vec3i [[color(4)]];
    metal::uint3 vec3u [[color(5)]];
    metal::float2 vec2f [[color(6)]];
    metal::int2 vec2i [[color(7)]];
    metal::uint2 vec2u [[color(8)]];
    float scalarf [[color(9)]];
    int scalari [[color(10)]];
    uint scalaru [[color(11)]];
};
fragment main_Output main_(
) {
    FragmentOutput output = {};
    output.vec4f = metal::float4(0.0);
    output.vec4i = metal::int4(0);
    output.vec4u = metal::uint4(0u);
    output.vec3f = metal::float3(0.0);
    output.vec3i = metal::int3(0);
    output.vec3u = metal::uint3(0u);
    output.vec2f = metal::float2(0.0);
    output.vec2i = metal::int2(0);
    output.vec2u = metal::uint2(0u);
    output.scalarf = 0.0;
    output.scalari = 0;
    output.scalaru = 0u;
    FragmentOutput _e34 = output;
    const auto _tmp = _e34;
    return main_Output { _tmp.vec4f, _tmp.vec4i, _tmp.vec4u, _tmp.vec3f, _tmp.vec3i, _tmp.vec3u, _tmp.vec2f, _tmp.vec2i, _tmp.vec2u, _tmp.scalarf, _tmp.scalari, _tmp.scalaru };
}
