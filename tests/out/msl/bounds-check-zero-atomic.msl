// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};
struct _mslBufferSizes {
    uint size0;
};

typedef metal::atomic_uint atomicu32_;
struct arrayatomicu3210_ {
    atomicu32_ inner[10u];
};
typedef atomicu32_ arrayatomicu32_[1];
struct Globals {
    atomicu32_ a;
    arrayatomicu3210_ b;
    arrayatomicu32_ c;
};
typedef uint u32_;
typedef device Globals& ptrstorageGlobals;
typedef device atomicu32_& ptrstorageatomicu32_;
typedef int i32_;

u32_ fetch_add_atomic(
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    uint _e3 = metal::atomic_fetch_add_explicit(&globals.a, 1u, metal::memory_order_relaxed);
    return _e3;
}

u32_ fetch_add_atomic_static_sized_array(
    i32_ i,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    uint _e5 = uint(i) < 10 ? metal::atomic_fetch_add_explicit(&globals.b.inner[i], 1u, metal::memory_order_relaxed) : DefaultConstructible();
    return _e5;
}

u32_ fetch_add_atomic_dynamic_sized_array(
    i32_ i_1,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    uint _e5 = uint(i_1) < 1 + (_buffer_sizes.size0 - 44 - 4) / 4 ? metal::atomic_fetch_add_explicit(&globals.c[i_1], 1u, metal::memory_order_relaxed) : DefaultConstructible();
    return _e5;
}
