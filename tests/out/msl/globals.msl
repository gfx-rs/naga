// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size3;
};

struct type_2 {
    float inner[10];
};
struct FooStruct {
    metal::packed_float3 v3_;
    float v1_;
};
typedef metal::float2 type_6[1];
struct type_8 {
    metal::float4 inner[20];
};
struct type_11 {
    metal::float2x4 inner[2];
};
struct type_12 {
    type_11 inner[2];
};
struct type_14 {
    metal::float4x2 inner[2];
};
struct type_15 {
    type_14 inner[2];
};
constant bool Foo_1 = true;
struct ArgumentBufferGroup0 {
    device FooStruct& alignment [[id(0)]];
    device type_6 const& dummy [[id(1)]];
    constant type_8& float_vecs [[id(2)]];
    constant metal::float3& global_vec [[id(22)]];
    constant metal::float3x2& global_mat [[id(23)]];
    constant type_12& global_nested_arrays_of_matrices_2x4_ [[id(24)]];
    constant type_15& global_nested_arrays_of_matrices_4x2_ [[id(26)]];
};

void test_msl_packed_vec3_as_arg(
    metal::float3 arg
) {
    return;
}

void test_msl_packed_vec3_(
    device FooStruct& alignment
) {
    int idx = {};
    alignment.v3_ = metal::float3(1.0);
    idx = 1;
    alignment.v3_[0] = 1.0;
    alignment.v3_[0] = 2.0;
    int _e17 = idx;
    alignment.v3_[_e17] = 3.0;
    FooStruct data = alignment;
    metal::float3 l0_ = data.v3_;
    metal::float2 l1_ = metal::float3(data.v3_).zx;
    test_msl_packed_vec3_as_arg(data.v3_);
    metal::float3 mvm0_ = metal::float3(data.v3_) * metal::float3x3 {};
    metal::float3 mvm1_ = metal::float3x3 {} * metal::float3(data.v3_);
    metal::float3 svm0_ = data.v3_ * 2.0;
    metal::float3 svm1_ = 2.0 * data.v3_;
}

kernel void main_(
  metal::uint3 __local_invocation_id [[thread_position_in_threadgroup]]
, threadgroup type_2& wg
, threadgroup metal::atomic_uint& at_1
, device ArgumentBufferGroup0& argumentBufferGroup0 [[buffer(0)]]
, constant _mslBufferSizes& _buffer_sizes [[user(fake0)]]
) {
    if (metal::all(__local_invocation_id == metal::uint3(0u))) {
        wg = {};
        metal::atomic_store_explicit(&at_1, 0, metal::memory_order_relaxed);
    }
    metal::threadgroup_barrier(metal::mem_flags::mem_threadgroup);
    float Foo = {};
    bool at = {};
    test_msl_packed_vec3_(argumentBufferGroup0.alignment);
    metal::float4x2 _e8 = argumentBufferGroup0.global_nested_arrays_of_matrices_4x2_.inner[0].inner[0];
    metal::float4 _e16 = argumentBufferGroup0.global_nested_arrays_of_matrices_2x4_.inner[0].inner[0][0];
    wg.inner[7] = (_e8 * _e16).x;
    metal::float3x2 _e23 = argumentBufferGroup0.global_mat;
    metal::float3 _e25 = argumentBufferGroup0.global_vec;
    wg.inner[6] = (_e23 * _e25).x;
    float _e35 = argumentBufferGroup0.dummy[1].y;
    wg.inner[5] = _e35;
    float _e43 = argumentBufferGroup0.float_vecs.inner[0].w;
    wg.inner[4] = _e43;
    float _e49 = argumentBufferGroup0.alignment.v1_;
    wg.inner[3] = _e49;
    float _e56 = argumentBufferGroup0.alignment.v3_[0];
    wg.inner[2] = _e56;
    argumentBufferGroup0.alignment.v1_ = 4.0;
    wg.inner[1] = static_cast<float>(1 + (_buffer_sizes.size3 - 0 - 8) / 8);
    metal::atomic_store_explicit(&at_1, 2u, metal::memory_order_relaxed);
    Foo = 1.0;
    at = true;
    return;
}
