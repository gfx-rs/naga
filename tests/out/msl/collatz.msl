// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size0;
};

typedef uint u32_;
typedef u32_ arrayu32_[1];
struct PrimeIndices {
    arrayu32_ data;
};
typedef metal::uint3 vec3u32_;
typedef device PrimeIndices& ptrstoragePrimeIndices;

u32_ collatz_iterations(
    u32_ n_base
) {
    u32_ n = {};
    u32_ i = {};
    n = n_base;
    i = 0u;
    while(true) {
        u32_ _e5 = n;
        if (_e5 > 1u) {
        } else {
            break;
        }
        {
            u32_ _e9 = n;
            if ((_e9 % 2u) == 0u) {
                u32_ _e15 = n;
                n = _e15 / 2u;
            } else {
                {
                    u32_ _e21 = n;
                    n = (3u * _e21) + 1u;
                }
            }
            u32_ _e27 = i;
            i = _e27 + 1u;
        }
    }
    u32_ _e32 = i;
    return _e32;
}

struct main_Input {
};
kernel void main_(
  vec3u32_ global_id [[thread_position_in_grid]]
, device PrimeIndices& v_indices [[user(fake0)]]
, constant _mslBufferSizes& _buffer_sizes [[user(fake0)]]
) {
    u32_ _e6 = v_indices.data[global_id.x];
    u32_ _e0 = collatz_iterations(_e6);
    v_indices.data[global_id.x] = _e0;
    return;
}
