// language: metal1.1
#include <metal_stdlib>
#include <simd/simd.h>

struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};
struct _mslBufferSizes {
    metal::uint size0;
};

struct type_1 {
    float inner[10];
};
struct type_5 {
    metal::atomic_uint inner[10];
};
typedef float type_6[1];
struct Globals {
    type_1 a;
    char _pad1[8];
    metal::float4 v;
    metal::float3x4 m;
    metal::atomic_uint b;
    type_5 g;
    type_6 d;
};

float index_array(
    int i,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e4 = metal::uint(i) < 10 ? globals.a.inner[i] : DefaultConstructible();
    return _e4;
}

float index_dynamic_array(
    int i_1,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e4 = metal::uint(i_1) < 1 + (_buffer_sizes.size0 - 156 - 4) / 4 ? globals.d[i_1] : DefaultConstructible();
    return _e4;
}

float index_vector(
    int i_2,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e4 = metal::uint(i_2) < 4 ? globals.v[i_2] : DefaultConstructible();
    return _e4;
}

float index_vector_by_value(
    metal::float4 v,
    int i_3
) {
    return metal::uint(i_3) < 4 ? v[i_3] : DefaultConstructible();
}

metal::float4 index_matrix(
    int i_4,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    metal::float4 _e4 = metal::uint(i_4) < 3 ? globals.m[i_4] : DefaultConstructible();
    return _e4;
}

float index_twice(
    int i_5,
    int j,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e6 = metal::uint(j) < 4 && metal::uint(i_5) < 3 ? globals.m[i_5][j] : DefaultConstructible();
    return _e6;
}

float index_expensive(
    int i_6,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    int _e9 = static_cast<int>(metal::sin(static_cast<float>(i_6) / 100.0) * 100.0);
    float _e11 = metal::uint(_e9) < 10 ? globals.a.inner[_e9] : DefaultConstructible();
    return _e11;
}

float index_in_bounds(
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e4 = globals.a.inner[9];
    float _e8 = globals.v.w;
    float _e15 = globals.m[2].w;
    return (_e4 + _e8) + _e15;
}

void set_array(
    int i_7,
    float v_1,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    if (metal::uint(i_7) < 10) {
        globals.a.inner[i_7] = v_1;
    }
    return;
}

void set_dynamic_array(
    int i_8,
    float v_2,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    if (metal::uint(i_8) < 1 + (_buffer_sizes.size0 - 156 - 4) / 4) {
        globals.d[i_8] = v_2;
    }
    return;
}

void set_vector(
    int i_9,
    float v_3,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    if (metal::uint(i_9) < 4) {
        globals.v[i_9] = v_3;
    }
    return;
}

void set_matrix(
    int i_10,
    metal::float4 v_4,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    if (metal::uint(i_10) < 3) {
        globals.m[i_10] = v_4;
    }
    return;
}

void set_index_twice(
    int i_11,
    int j_1,
    float v_5,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    if (metal::uint(j_1) < 4 && metal::uint(i_11) < 3) {
        globals.m[i_11][j_1] = v_5;
    }
    return;
}

void set_expensive(
    int i_12,
    float v_6,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    int _e10 = static_cast<int>(metal::sin(static_cast<float>(i_12) / 100.0) * 100.0);
    if (metal::uint(_e10) < 10) {
        globals.a.inner[_e10] = v_6;
    }
    return;
}

void set_in_bounds(
    float v_7,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.a.inner[9] = v_7;
    globals.v.w = v_7;
    globals.m[2].w = v_7;
    return;
}

metal::uint fetch_add_atomic(
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    metal::uint _e3 = metal::atomic_fetch_add_explicit(&globals.b, 1u, metal::memory_order_relaxed);
    return _e3;
}

metal::uint fetch_add_atomic_array(
    int i_13,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    metal::uint _e5 = (metal::uint(i_13) < 10 ? metal::atomic_fetch_add_explicit(&globals.g.inner[i_13], 1u, metal::memory_order_relaxed) : DefaultConstructible());
    return _e5;
}
