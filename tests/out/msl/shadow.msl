// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size2;
};

constexpr constant unsigned c_max_lights = 10u;
typedef metal::float4x4 mat4x4f32_;
typedef metal::uint4 vec4u32_;
struct Globals {
    mat4x4f32_ view_proj;
    vec4u32_ num_lights;
};
typedef metal::float4 vec4f32_;
struct Entity {
    mat4x4f32_ world;
    vec4f32_ color;
};
typedef metal::float3 vec3f32_;
struct VertexOutput {
    vec4f32_ proj_position;
    vec3f32_ world_normal;
    vec4f32_ world_position;
};
typedef metal::int4 vec4i32_;
typedef constant Entity& ptruniformEntity;
typedef metal::float3x3 mat3x3f32_;
typedef metal::int3 vec3i32_;
typedef thread VertexOutput& ptrfunctionVertexOutput;
typedef constant Globals& ptruniformGlobals;
struct Light {
    mat4x4f32_ proj;
    vec4f32_ pos;
    vec4f32_ color;
};
typedef Light arrayLight[1];
struct arrayLight10_ {
    Light inner[10u];
};
typedef uint u32_;
typedef float f32_;
typedef metal::float2 vec2f32_;
typedef int i32_;
typedef constant vec4u32_& ptruniformvec4u32_;
typedef device arrayLight& ptrstoragearrayLight;
typedef constant arrayLight10_& ptruniformarrayLight10_;
constant vec3f32_ c_ambient = {0.05, 0.05, 0.05};

f32_ fetch_shadow(
    u32_ light_id,
    vec4f32_ homogeneous_coords,
    metal::depth2d_array<float, metal::access::sample> t_shadow,
    metal::sampler sampler_shadow
) {
    if (homogeneous_coords.w <= 0.0) {
        return 1.0;
    }
    vec2f32_ flip_correction = metal::float2(0.5, -0.5);
    float proj_correction = 1.0 / homogeneous_coords.w;
    metal::float2 light_local = ((homogeneous_coords.xy * flip_correction) * proj_correction) + metal::float2(0.5, 0.5);
    float _e28 = t_shadow.sample_compare(sampler_shadow, light_local, static_cast<int>(light_id), homogeneous_coords.z * proj_correction);
    return _e28;
}

struct vs_mainInput {
    vec4i32_ position [[attribute(0)]];
    vec4i32_ normal [[attribute(1)]];
};
struct vs_mainOutput {
    metal::float4 proj_position [[position]];
    metal::float3 world_normal [[user(loc0), center_perspective]];
    metal::float4 world_position [[user(loc1), center_perspective]];
};
vertex vs_mainOutput vs_main(
  vs_mainInput varyings [[stage_in]]
, constant Globals& u_globals [[user(fake0)]]
, constant Entity& u_entity [[user(fake0)]]
) {
    const auto position = varyings.position;
    const auto normal = varyings.normal;
    VertexOutput out = {};
    mat4x4f32_ w = u_entity.world;
    mat4x4f32_ _e5 = u_entity.world;
    metal::float4 world_pos = _e5 * static_cast<metal::float4>(position);
    out.world_normal = metal::float3x3(w[0].xyz, w[1].xyz, w[2].xyz) * static_cast<metal::float3>(normal.xyz);
    out.world_position = world_pos;
    mat4x4f32_ _e26 = u_globals.view_proj;
    out.proj_position = _e26 * world_pos;
    VertexOutput _e31 = out;
    const auto _tmp = _e31;
    return vs_mainOutput { _tmp.proj_position, _tmp.world_normal, _tmp.world_position };
}


struct fs_mainInput {
    vec3f32_ world_normal [[user(loc0), center_perspective]];
    vec4f32_ world_position [[user(loc1), center_perspective]];
};
struct fs_mainOutput {
    metal::float4 member_1 [[color(0)]];
};
fragment fs_mainOutput fs_main(
  fs_mainInput varyings_1 [[stage_in]]
, vec4f32_ proj_position [[position]]
, constant Globals& u_globals [[user(fake0)]]
, constant Entity& u_entity [[user(fake0)]]
, device arrayLight const& s_lights [[user(fake0)]]
, metal::depth2d_array<float, metal::access::sample> t_shadow [[user(fake0)]]
, metal::sampler sampler_shadow [[user(fake0)]]
, constant _mslBufferSizes& _buffer_sizes [[user(fake0)]]
) {
    const VertexOutput in = { proj_position, varyings_1.world_normal, varyings_1.world_position };
    vec3f32_ color = {};
    u32_ i = {};
    vec3f32_ normal_1 = metal::normalize(in.world_normal);
    color = c_ambient;
    {
        i = 0u;
        bool loop_init = true;
        while(true) {
            if (!loop_init) {
                u32_ _e46 = i;
                i = _e46 + 1u;
            }
            loop_init = false;
            u32_ _e8 = i;
            uint _e12 = u_globals.num_lights.x;
            if (_e8 < metal::min(_e12, c_max_lights)) {
            } else {
                break;
            }
            {
                u32_ _e18 = i;
                Light light = s_lights[_e18];
                u32_ _e23 = i;
                f32_ _e21 = fetch_shadow(_e23, light.proj * in.world_position, t_shadow, sampler_shadow);
                metal::float3 light_dir = metal::normalize(light.pos.xyz - in.world_position.xyz);
                float diffuse = metal::max(0.0, metal::dot(normal_1, light_dir));
                vec3f32_ _e43 = color;
                color = _e43 + ((_e21 * diffuse) * light.color.xyz);
            }
        }
    }
    vec3f32_ _e50 = color;
    vec4f32_ _e55 = u_entity.color;
    return fs_mainOutput { metal::float4(_e50, 1.0) * _e55 };
}


struct fs_main_without_storageInput {
    vec3f32_ world_normal [[user(loc0), center_perspective]];
    vec4f32_ world_position [[user(loc1), center_perspective]];
};
struct fs_main_without_storageOutput {
    metal::float4 member_2 [[color(0)]];
};
fragment fs_main_without_storageOutput fs_main_without_storage(
  fs_main_without_storageInput varyings_2 [[stage_in]]
, vec4f32_ proj_position_1 [[position]]
, constant Globals& u_globals [[user(fake0)]]
, constant Entity& u_entity [[user(fake0)]]
, constant arrayLight10_& u_lights [[user(fake0)]]
, metal::depth2d_array<float, metal::access::sample> t_shadow [[user(fake0)]]
, metal::sampler sampler_shadow [[user(fake0)]]
) {
    const VertexOutput in_1 = { proj_position_1, varyings_2.world_normal, varyings_2.world_position };
    vec3f32_ color_1 = {};
    u32_ i_1 = {};
    vec3f32_ normal_2 = metal::normalize(in_1.world_normal);
    color_1 = c_ambient;
    {
        i_1 = 0u;
        bool loop_init_1 = true;
        while(true) {
            if (!loop_init_1) {
                u32_ _e46 = i_1;
                i_1 = _e46 + 1u;
            }
            loop_init_1 = false;
            u32_ _e8 = i_1;
            uint _e12 = u_globals.num_lights.x;
            if (_e8 < metal::min(_e12, c_max_lights)) {
            } else {
                break;
            }
            {
                u32_ _e18 = i_1;
                Light light_1 = u_lights.inner[_e18];
                u32_ _e23 = i_1;
                f32_ _e21 = fetch_shadow(_e23, light_1.proj * in_1.world_position, t_shadow, sampler_shadow);
                metal::float3 light_dir_1 = metal::normalize(light_1.pos.xyz - in_1.world_position.xyz);
                float diffuse_1 = metal::max(0.0, metal::dot(normal_2, light_dir_1));
                vec3f32_ _e43 = color_1;
                color_1 = _e43 + ((_e21 * diffuse_1) * light_1.color.xyz);
            }
        }
    }
    vec3f32_ _e50 = color_1;
    vec4f32_ _e55 = u_entity.color;
    return fs_main_without_storageOutput { metal::float4(_e50, 1.0) * _e55 };
}
