// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};
typedef int i32_;
typedef metal::float4 vec4f32_;
typedef metal::int2 vec2i32_;
typedef metal::int3 vec3i32_;
typedef float f32_;
constant vec2i32_ const_vec2i32_ = {0, 0};
constant vec3i32_ const_vec3i32_ = {0, 0, 0};
constant vec4f32_ const_vec4f32_ = {0.0, 0.0, 0.0, 0.0};

vec4f32_ test_textureLoad_1d(
    i32_ coords,
    i32_ level,
    metal::texture1d<float, metal::access::sample> image_1d
) {
    metal::float4 _e3 = (uint(level) < image_1d.get_num_mip_levels() && uint(coords) < image_1d.get_width() ? image_1d.read(uint(coords)): DefaultConstructible());
    return _e3;
}

vec4f32_ test_textureLoad_2d(
    vec2i32_ coords_1,
    i32_ level_1,
    metal::texture2d<float, metal::access::sample> image_2d
) {
    metal::float4 _e3 = (uint(level_1) < image_2d.get_num_mip_levels() && metal::all(metal::uint2(coords_1) < metal::uint2(image_2d.get_width(level_1), image_2d.get_height(level_1))) ? image_2d.read(metal::uint2(coords_1), level_1): DefaultConstructible());
    return _e3;
}

vec4f32_ test_textureLoad_2d_array(
    vec2i32_ coords_2,
    i32_ index,
    i32_ level_2,
    metal::texture2d_array<float, metal::access::sample> image_2d_array
) {
    metal::float4 _e4 = (uint(level_2) < image_2d_array.get_num_mip_levels() && uint(index) < image_2d_array.get_array_size() && metal::all(metal::uint2(coords_2) < metal::uint2(image_2d_array.get_width(level_2), image_2d_array.get_height(level_2))) ? image_2d_array.read(metal::uint2(coords_2), index, level_2): DefaultConstructible());
    return _e4;
}

vec4f32_ test_textureLoad_3d(
    vec3i32_ coords_3,
    i32_ level_3,
    metal::texture3d<float, metal::access::sample> image_3d
) {
    metal::float4 _e3 = (uint(level_3) < image_3d.get_num_mip_levels() && metal::all(metal::uint3(coords_3) < metal::uint3(image_3d.get_width(level_3), image_3d.get_height(level_3), image_3d.get_depth(level_3))) ? image_3d.read(metal::uint3(coords_3), level_3): DefaultConstructible());
    return _e3;
}

vec4f32_ test_textureLoad_multisampled_2d(
    vec2i32_ coords_4,
    i32_ _sample,
    metal::texture2d_ms<float, metal::access::read> image_multisampled_2d
) {
    metal::float4 _e3 = (uint(_sample) < image_multisampled_2d.get_num_samples() && metal::all(metal::uint2(coords_4) < metal::uint2(image_multisampled_2d.get_width(), image_multisampled_2d.get_height())) ? image_multisampled_2d.read(metal::uint2(coords_4), _sample): DefaultConstructible());
    return _e3;
}

f32_ test_textureLoad_depth_2d(
    vec2i32_ coords_5,
    i32_ level_4,
    metal::depth2d<float, metal::access::sample> image_depth_2d
) {
    float _e3 = (uint(level_4) < image_depth_2d.get_num_mip_levels() && metal::all(metal::uint2(coords_5) < metal::uint2(image_depth_2d.get_width(level_4), image_depth_2d.get_height(level_4))) ? image_depth_2d.read(metal::uint2(coords_5), level_4): DefaultConstructible());
    return _e3;
}

f32_ test_textureLoad_depth_2d_array(
    vec2i32_ coords_6,
    i32_ index_1,
    i32_ level_5,
    metal::depth2d_array<float, metal::access::sample> image_depth_2d_array
) {
    float _e4 = (uint(level_5) < image_depth_2d_array.get_num_mip_levels() && uint(index_1) < image_depth_2d_array.get_array_size() && metal::all(metal::uint2(coords_6) < metal::uint2(image_depth_2d_array.get_width(level_5), image_depth_2d_array.get_height(level_5))) ? image_depth_2d_array.read(metal::uint2(coords_6), index_1, level_5): DefaultConstructible());
    return _e4;
}

f32_ test_textureLoad_depth_multisampled_2d(
    vec2i32_ coords_7,
    i32_ _sample_1,
    metal::depth2d_ms<float, metal::access::read> image_depth_multisampled_2d
) {
    float _e3 = (uint(_sample_1) < image_depth_multisampled_2d.get_num_samples() && metal::all(metal::uint2(coords_7) < metal::uint2(image_depth_multisampled_2d.get_width(), image_depth_multisampled_2d.get_height())) ? image_depth_multisampled_2d.read(metal::uint2(coords_7), _sample_1): DefaultConstructible());
    return _e3;
}

void test_textureStore_1d(
    i32_ coords_8,
    vec4f32_ value,
    metal::texture1d<float, metal::access::write> image_storage_1d
) {
    if (uint(coords_8) < image_storage_1d.get_width()) {
        image_storage_1d.write(value, uint(coords_8));
    }
    return;
}

void test_textureStore_2d(
    vec2i32_ coords_9,
    vec4f32_ value_1,
    metal::texture2d<float, metal::access::write> image_storage_2d
) {
    if (metal::all(metal::uint2(coords_9) < metal::uint2(image_storage_2d.get_width(), image_storage_2d.get_height()))) {
        image_storage_2d.write(value_1, metal::uint2(coords_9));
    }
    return;
}

void test_textureStore_2d_array(
    vec2i32_ coords_10,
    i32_ array_index,
    vec4f32_ value_2,
    metal::texture2d_array<float, metal::access::write> image_storage_2d_array
) {
    if (uint(array_index) < image_storage_2d_array.get_array_size() && metal::all(metal::uint2(coords_10) < metal::uint2(image_storage_2d_array.get_width(), image_storage_2d_array.get_height()))) {
        image_storage_2d_array.write(value_2, metal::uint2(coords_10), array_index);
    }
    return;
}

void test_textureStore_3d(
    vec3i32_ coords_11,
    vec4f32_ value_3,
    metal::texture3d<float, metal::access::write> image_storage_3d
) {
    if (metal::all(metal::uint3(coords_11) < metal::uint3(image_storage_3d.get_width(), image_storage_3d.get_height(), image_storage_3d.get_depth()))) {
        image_storage_3d.write(value_3, metal::uint3(coords_11));
    }
    return;
}

struct fragment_shaderOutput {
    metal::float4 member [[color(0)]];
};
fragment fragment_shaderOutput fragment_shader(
  metal::texture1d<float, metal::access::sample> image_1d [[user(fake0)]]
, metal::texture2d<float, metal::access::sample> image_2d [[user(fake0)]]
, metal::texture2d_array<float, metal::access::sample> image_2d_array [[user(fake0)]]
, metal::texture3d<float, metal::access::sample> image_3d [[user(fake0)]]
, metal::texture2d_ms<float, metal::access::read> image_multisampled_2d [[user(fake0)]]
, metal::texture1d<float, metal::access::write> image_storage_1d [[user(fake0)]]
, metal::texture2d<float, metal::access::write> image_storage_2d [[user(fake0)]]
, metal::texture2d_array<float, metal::access::write> image_storage_2d_array [[user(fake0)]]
, metal::texture3d<float, metal::access::write> image_storage_3d [[user(fake0)]]
) {
    vec4f32_ _e0 = test_textureLoad_1d(0, 0, image_1d);
    vec4f32_ _e3 = test_textureLoad_2d(const_vec2i32_, 0, image_2d);
    vec4f32_ _e6 = test_textureLoad_2d_array(const_vec2i32_, 0, 0, image_2d_array);
    vec4f32_ _e10 = test_textureLoad_3d(const_vec3i32_, 0, image_3d);
    vec4f32_ _e13 = test_textureLoad_multisampled_2d(const_vec2i32_, 0, image_multisampled_2d);
    test_textureStore_1d(0, const_vec4f32_, image_storage_1d);
    test_textureStore_2d(const_vec2i32_, const_vec4f32_, image_storage_2d);
    test_textureStore_2d_array(const_vec2i32_, 0, const_vec4f32_, image_storage_2d_array);
    test_textureStore_3d(const_vec3i32_, const_vec4f32_, image_storage_3d);
    return fragment_shaderOutput { metal::float4(0.0, 0.0, 0.0, 0.0) };
}
