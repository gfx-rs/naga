// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct _mslBufferSizes {
    uint size0;
};

typedef float f32_;
struct arrayf3210_ {
    f32_ inner[10u];
};
typedef metal::float4 vec4f32_;
typedef metal::float3x4 mat3x4f32_;
typedef f32_ arrayf32_[1];
struct Globals {
    arrayf3210_ a;
    char _pad1[8];
    vec4f32_ v;
    mat3x4f32_ m;
    arrayf32_ d;
};
typedef int i32_;
typedef device Globals& ptrstorageGlobals;
typedef device arrayf3210_& ptrstoragearrayf3210_;
typedef device arrayf32_& ptrstoragearrayf32_;
typedef device vec4f32_& ptrstoragevec4f32_;
typedef device mat3x4f32_& ptrstoragemat3x4f32_;
typedef device metal::float4& ptrstoragevec4f32_1;

f32_ index_array(
    i32_ i,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    f32_ _e4 = globals.a.inner[metal::min(unsigned(i), 9u)];
    return _e4;
}

f32_ index_dynamic_array(
    i32_ i_1,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    f32_ _e4 = globals.d[metal::min(unsigned(i_1), (_buffer_sizes.size0 - 112 - 4) / 4)];
    return _e4;
}

f32_ index_vector(
    i32_ i_2,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e4 = globals.v[metal::min(unsigned(i_2), 3u)];
    return _e4;
}

f32_ index_vector_by_value(
    vec4f32_ v,
    i32_ i_3
) {
    return v[metal::min(unsigned(i_3), 3u)];
}

vec4f32_ index_matrix(
    i32_ i_4,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    metal::float4 _e4 = globals.m[metal::min(unsigned(i_4), 2u)];
    return _e4;
}

f32_ index_twice(
    i32_ i_5,
    i32_ j,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    float _e6 = globals.m[metal::min(unsigned(i_5), 2u)][metal::min(unsigned(j), 3u)];
    return _e6;
}

f32_ index_expensive(
    i32_ i_6,
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    f32_ _e11 = globals.a.inner[metal::min(unsigned(static_cast<int>(metal::sin(static_cast<float>(i_6) / 100.0) * 100.0)), 9u)];
    return _e11;
}

f32_ index_in_bounds(
    device Globals const& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    f32_ _e4 = globals.a.inner[9];
    float _e9 = globals.v.w;
    float _e17 = globals.m[2].w;
    return (_e4 + _e9) + _e17;
}

void set_array(
    i32_ i_7,
    f32_ v_1,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.a.inner[metal::min(unsigned(i_7), 9u)] = v_1;
    return;
}

void set_dynamic_array(
    i32_ i_8,
    f32_ v_2,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.d[metal::min(unsigned(i_8), (_buffer_sizes.size0 - 112 - 4) / 4)] = v_2;
    return;
}

void set_vector(
    i32_ i_9,
    f32_ v_3,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.v[metal::min(unsigned(i_9), 3u)] = v_3;
    return;
}

void set_matrix(
    i32_ i_10,
    vec4f32_ v_4,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.m[metal::min(unsigned(i_10), 2u)] = v_4;
    return;
}

void set_index_twice(
    i32_ i_11,
    i32_ j_1,
    f32_ v_5,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.m[metal::min(unsigned(i_11), 2u)][metal::min(unsigned(j_1), 3u)] = v_5;
    return;
}

void set_expensive(
    i32_ i_12,
    f32_ v_6,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.a.inner[metal::min(unsigned(static_cast<int>(metal::sin(static_cast<float>(i_12) / 100.0) * 100.0)), 9u)] = v_6;
    return;
}

void set_in_bounds(
    f32_ v_7,
    device Globals& globals,
    constant _mslBufferSizes& _buffer_sizes
) {
    globals.a.inner[9] = v_7;
    globals.v.w = v_7;
    globals.m[2].w = v_7;
    return;
}
