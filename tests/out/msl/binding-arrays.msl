// language: metal2.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct DefaultConstructible {
    template<typename T>
    operator T() && {
        return T {};
    }
};
typedef uint u32_;
struct UniformIndex {
    u32_ index;
};
typedef int i32_;
struct FragmentIn {
    u32_ index;
};
typedef metal::float4 vec4f32_;
typedef constant UniformIndex& ptruniformUniformIndex;
typedef metal::int2 vec2i32_;
typedef float f32_;
typedef metal::float2 vec2f32_;

struct main_Input {
    u32_ index [[user(loc0), flat]];
};
struct main_Output {
    metal::float4 member [[color(0)]];
};
fragment main_Output main_(
  main_Input varyings [[stage_in]]
, metal::array<metal::texture2d<float, metal::access::sample>, 10> texture_array_unbounded [[texture(0)]]
, metal::array<metal::texture2d<float, metal::access::sample>, 5> texture_array_bounded [[user(fake0)]]
, metal::array<metal::texture2d_array<float, metal::access::sample>, 5> texture_array_2darray [[user(fake0)]]
, metal::array<metal::texture2d_ms<float, metal::access::read>, 5> texture_array_multisampled [[user(fake0)]]
, metal::array<metal::depth2d<float, metal::access::sample>, 5> texture_array_depth [[user(fake0)]]
, metal::array<metal::texture2d<float, metal::access::write>, 5> texture_array_storage [[user(fake0)]]
, metal::array<metal::sampler, 5> samp [[user(fake0)]]
, metal::array<metal::sampler, 5> samp_comp [[user(fake0)]]
, constant UniformIndex& uni [[user(fake0)]]
) {
    const FragmentIn fragment_in = { varyings.index };
    i32_ i1_ = {};
    vec2i32_ i2_ = {};
    f32_ v1_ = {};
    vec4f32_ v4_ = {};
    u32_ uniform_index = uni.index;
    u32_ non_uniform_index = fragment_in.index;
    i1_ = 0;
    metal::int2 i2_1 = metal::int2(0);
    i2_ = i2_1;
    v1_ = 0.0;
    metal::float4 v4_1 = metal::float4(0.0);
    v4_ = v4_1;
    metal::float2 uv = metal::float2(0.0);
    metal::int2 pix = metal::int2(0);
    vec2i32_ _e24 = i2_;
    i2_ = _e24 + metal::int2(texture_array_unbounded[0].get_width(), texture_array_unbounded[0].get_height());
    vec2i32_ _e30 = i2_;
    i2_ = _e30 + metal::int2(texture_array_unbounded[uniform_index].get_width(), texture_array_unbounded[uniform_index].get_height());
    vec2i32_ _e36 = i2_;
    i2_ = _e36 + metal::int2(texture_array_unbounded[non_uniform_index].get_width(), texture_array_unbounded[non_uniform_index].get_height());
    metal::float4 _e44 = texture_array_bounded[0].gather(samp[0], uv);
    vec4f32_ _e46 = v4_;
    v4_ = _e46 + _e44;
    metal::float4 _e52 = texture_array_bounded[uniform_index].gather(samp[uniform_index], uv);
    vec4f32_ _e54 = v4_;
    v4_ = _e54 + _e52;
    metal::float4 _e60 = texture_array_bounded[non_uniform_index].gather(samp[non_uniform_index], uv);
    vec4f32_ _e62 = v4_;
    v4_ = _e62 + _e60;
    metal::float4 _e71 = texture_array_depth[0].gather_compare(samp_comp[0], uv, 0.0);
    vec4f32_ _e73 = v4_;
    v4_ = _e73 + _e71;
    metal::float4 _e80 = texture_array_depth[uniform_index].gather_compare(samp_comp[uniform_index], uv, 0.0);
    vec4f32_ _e82 = v4_;
    v4_ = _e82 + _e80;
    metal::float4 _e89 = texture_array_depth[non_uniform_index].gather_compare(samp_comp[non_uniform_index], uv, 0.0);
    vec4f32_ _e91 = v4_;
    v4_ = _e91 + _e89;
    metal::float4 _e97 = (uint(0) < texture_array_unbounded[0].get_num_mip_levels() && metal::all(metal::uint2(pix) < metal::uint2(texture_array_unbounded[0].get_width(0), texture_array_unbounded[0].get_height(0))) ? texture_array_unbounded[0].read(metal::uint2(pix), 0): DefaultConstructible());
    vec4f32_ _e99 = v4_;
    v4_ = _e99 + _e97;
    metal::float4 _e104 = (uint(0) < texture_array_unbounded[uniform_index].get_num_mip_levels() && metal::all(metal::uint2(pix) < metal::uint2(texture_array_unbounded[uniform_index].get_width(0), texture_array_unbounded[uniform_index].get_height(0))) ? texture_array_unbounded[uniform_index].read(metal::uint2(pix), 0): DefaultConstructible());
    vec4f32_ _e106 = v4_;
    v4_ = _e106 + _e104;
    metal::float4 _e111 = (uint(0) < texture_array_unbounded[non_uniform_index].get_num_mip_levels() && metal::all(metal::uint2(pix) < metal::uint2(texture_array_unbounded[non_uniform_index].get_width(0), texture_array_unbounded[non_uniform_index].get_height(0))) ? texture_array_unbounded[non_uniform_index].read(metal::uint2(pix), 0): DefaultConstructible());
    vec4f32_ _e113 = v4_;
    v4_ = _e113 + _e111;
    i32_ _e120 = i1_;
    i1_ = _e120 + int(texture_array_2darray[0].get_array_size());
    i32_ _e126 = i1_;
    i1_ = _e126 + int(texture_array_2darray[uniform_index].get_array_size());
    i32_ _e132 = i1_;
    i1_ = _e132 + int(texture_array_2darray[non_uniform_index].get_array_size());
    i32_ _e139 = i1_;
    i1_ = _e139 + int(texture_array_bounded[0].get_num_mip_levels());
    i32_ _e145 = i1_;
    i1_ = _e145 + int(texture_array_bounded[uniform_index].get_num_mip_levels());
    i32_ _e151 = i1_;
    i1_ = _e151 + int(texture_array_bounded[non_uniform_index].get_num_mip_levels());
    i32_ _e158 = i1_;
    i1_ = _e158 + int(texture_array_multisampled[0].get_num_samples());
    i32_ _e164 = i1_;
    i1_ = _e164 + int(texture_array_multisampled[uniform_index].get_num_samples());
    i32_ _e170 = i1_;
    i1_ = _e170 + int(texture_array_multisampled[non_uniform_index].get_num_samples());
    metal::float4 _e178 = texture_array_bounded[0].sample(samp[0], uv);
    vec4f32_ _e180 = v4_;
    v4_ = _e180 + _e178;
    metal::float4 _e186 = texture_array_bounded[uniform_index].sample(samp[uniform_index], uv);
    vec4f32_ _e188 = v4_;
    v4_ = _e188 + _e186;
    metal::float4 _e194 = texture_array_bounded[non_uniform_index].sample(samp[non_uniform_index], uv);
    vec4f32_ _e196 = v4_;
    v4_ = _e196 + _e194;
    metal::float4 _e205 = texture_array_bounded[0].sample(samp[0], uv, metal::bias(0.0));
    vec4f32_ _e207 = v4_;
    v4_ = _e207 + _e205;
    metal::float4 _e214 = texture_array_bounded[uniform_index].sample(samp[uniform_index], uv, metal::bias(0.0));
    vec4f32_ _e216 = v4_;
    v4_ = _e216 + _e214;
    metal::float4 _e223 = texture_array_bounded[non_uniform_index].sample(samp[non_uniform_index], uv, metal::bias(0.0));
    vec4f32_ _e225 = v4_;
    v4_ = _e225 + _e223;
    float _e234 = texture_array_depth[0].sample_compare(samp_comp[0], uv, 0.0);
    f32_ _e236 = v1_;
    v1_ = _e236 + _e234;
    float _e243 = texture_array_depth[uniform_index].sample_compare(samp_comp[uniform_index], uv, 0.0);
    f32_ _e245 = v1_;
    v1_ = _e245 + _e243;
    float _e252 = texture_array_depth[non_uniform_index].sample_compare(samp_comp[non_uniform_index], uv, 0.0);
    f32_ _e254 = v1_;
    v1_ = _e254 + _e252;
    float _e263 = texture_array_depth[0].sample_compare(samp_comp[0], uv, 0.0);
    f32_ _e265 = v1_;
    v1_ = _e265 + _e263;
    float _e272 = texture_array_depth[uniform_index].sample_compare(samp_comp[uniform_index], uv, 0.0);
    f32_ _e274 = v1_;
    v1_ = _e274 + _e272;
    float _e281 = texture_array_depth[non_uniform_index].sample_compare(samp_comp[non_uniform_index], uv, 0.0);
    f32_ _e283 = v1_;
    v1_ = _e283 + _e281;
    metal::float4 _e291 = texture_array_bounded[0].sample(samp[0], uv, metal::gradient2d(uv, uv));
    vec4f32_ _e293 = v4_;
    v4_ = _e293 + _e291;
    metal::float4 _e299 = texture_array_bounded[uniform_index].sample(samp[uniform_index], uv, metal::gradient2d(uv, uv));
    vec4f32_ _e301 = v4_;
    v4_ = _e301 + _e299;
    metal::float4 _e307 = texture_array_bounded[non_uniform_index].sample(samp[non_uniform_index], uv, metal::gradient2d(uv, uv));
    vec4f32_ _e309 = v4_;
    v4_ = _e309 + _e307;
    metal::float4 _e318 = texture_array_bounded[0].sample(samp[0], uv, metal::level(0.0));
    vec4f32_ _e320 = v4_;
    v4_ = _e320 + _e318;
    metal::float4 _e327 = texture_array_bounded[uniform_index].sample(samp[uniform_index], uv, metal::level(0.0));
    vec4f32_ _e329 = v4_;
    v4_ = _e329 + _e327;
    metal::float4 _e336 = texture_array_bounded[non_uniform_index].sample(samp[non_uniform_index], uv, metal::level(0.0));
    vec4f32_ _e338 = v4_;
    v4_ = _e338 + _e336;
    vec4f32_ _e344 = v4_;
    if (metal::all(metal::uint2(pix) < metal::uint2(texture_array_storage[0].get_width(), texture_array_storage[0].get_height()))) {
        texture_array_storage[0].write(_e344, metal::uint2(pix));
    }
    vec4f32_ _e348 = v4_;
    if (metal::all(metal::uint2(pix) < metal::uint2(texture_array_storage[uniform_index].get_width(), texture_array_storage[uniform_index].get_height()))) {
        texture_array_storage[uniform_index].write(_e348, metal::uint2(pix));
    }
    vec4f32_ _e352 = v4_;
    if (metal::all(metal::uint2(pix) < metal::uint2(texture_array_storage[non_uniform_index].get_width(), texture_array_storage[non_uniform_index].get_height()))) {
        texture_array_storage[non_uniform_index].write(_e352, metal::uint2(pix));
    }
    vec2i32_ _e354 = i2_;
    i32_ _e356 = i1_;
    metal::float2 v2_ = static_cast<metal::float2>(_e354 + metal::int2(_e356));
    vec4f32_ _e361 = v4_;
    f32_ _e369 = v1_;
    return main_Output { (_e361 + metal::float4(v2_.x, v2_.y, v2_.x, v2_.y)) + metal::float4(_e369) };
}
