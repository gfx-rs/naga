fn main1() {
    var a: vec4<f32> = vec4<f32>(1.0, 1.0, 1.0, 1.0);
    var b: vec4<f32> = vec4<f32>(2.0, 2.0, 2.0, 2.0);
    var m: mat4x4<f32>;
    var i: i32 = 5;
    var ceilOut: vec4<f32>;
    var roundOut: vec4<f32>;
    var floorOut: vec4<f32>;
    var fractOut: vec4<f32>;
    var truncOut: vec4<f32>;
    var sinOut: vec4<f32>;
    var absOut: vec4<f32>;
    var sqrtOut: vec4<f32>;
    var inversesqrtOut: vec4<f32>;
    var expOut: vec4<f32>;
    var exp2Out: vec4<f32>;
    var signOut: vec4<f32>;
    var transposeOut: mat4x4<f32>;
    var normalizeOut: vec4<f32>;
    var sinhOut: vec4<f32>;
    var cosOut: vec4<f32>;
    var coshOut: vec4<f32>;
    var tanOut: vec4<f32>;
    var tanhOut: vec4<f32>;
    var acosOut: vec4<f32>;
    var asinOut: vec4<f32>;
    var logOut: vec4<f32>;
    var log2Out: vec4<f32>;
    var lengthOut: f32;
    var determinantOut: f32;
    var bitCountOut: i32;
    var bitfieldReverseOut: i32;
    var atanOut: f32;
    var atan2Out: f32;
    var modOut: f32;
    var powOut: vec4<f32>;
    var dotOut: f32;
    var maxOut: vec4<f32>;
    var minOut: vec4<f32>;
    var reflectOut: vec4<f32>;
    var crossOut: vec3<f32>;
    var outerProductOut: mat4x4<f32>;
    var distanceOut: f32;
    var stepOut: vec4<f32>;

    let _e6: vec4<f32> = a;
    let _e7: vec4<f32> = b;
    let _e8: vec4<f32> = a;
    let _e9: vec4<f32> = b;
    m = mat4x4<f32>(vec4<f32>(_e6.x, _e6.y, _e6.z, _e6.w), vec4<f32>(_e7.x, _e7.y, _e7.z, _e7.w), vec4<f32>(_e8.x, _e8.y, _e8.z, _e8.w), vec4<f32>(_e9.x, _e9.y, _e9.z, _e9.w));
    let _e34: vec4<f32> = a;
    ceilOut = ceil(_e34);
    let _e37: vec4<f32> = a;
    roundOut = round(_e37);
    let _e40: vec4<f32> = a;
    floorOut = floor(_e40);
    let _e43: vec4<f32> = a;
    fractOut = fract(_e43);
    let _e46: vec4<f32> = a;
    truncOut = trunc(_e46);
    let _e49: vec4<f32> = a;
    sinOut = sin(_e49);
    let _e52: vec4<f32> = a;
    absOut = abs(_e52);
    let _e55: vec4<f32> = a;
    sqrtOut = sqrt(_e55);
    let _e58: vec4<f32> = a;
    inversesqrtOut = inverseSqrt(_e58);
    let _e61: vec4<f32> = a;
    expOut = exp(_e61);
    let _e64: vec4<f32> = a;
    exp2Out = exp2(_e64);
    let _e67: vec4<f32> = a;
    signOut = sign(_e67);
    let _e70: mat4x4<f32> = m;
    transposeOut = transpose(_e70);
    let _e73: vec4<f32> = a;
    normalizeOut = normalize(_e73);
    let _e76: vec4<f32> = a;
    sinhOut = sinh(_e76);
    let _e79: vec4<f32> = a;
    cosOut = cos(_e79);
    let _e82: vec4<f32> = a;
    coshOut = cosh(_e82);
    let _e85: vec4<f32> = a;
    tanOut = tan(_e85);
    let _e88: vec4<f32> = a;
    tanhOut = tanh(_e88);
    let _e91: vec4<f32> = a;
    acosOut = acos(_e91);
    let _e94: vec4<f32> = a;
    asinOut = asin(_e94);
    let _e97: vec4<f32> = a;
    logOut = log(_e97);
    let _e100: vec4<f32> = a;
    log2Out = log2(_e100);
    let _e103: vec4<f32> = a;
    lengthOut = length(_e103);
    let _e106: mat4x4<f32> = m;
    determinantOut = determinant(_e106);
    let _e109: i32 = i;
    bitCountOut = countOneBits(_e109);
    let _e112: i32 = i;
    bitfieldReverseOut = reverseBits(_e112);
    let _e115: vec4<f32> = a;
    atanOut = atan(_e115.x);
    let _e119: vec4<f32> = a;
    let _e121: vec4<f32> = a;
    atan2Out = atan2(_e119.x, _e121.y);
    let _e125: vec4<f32> = a;
    let _e127: vec4<f32> = b;
    modOut = (_e125.x % _e127.x);
    let _e131: vec4<f32> = a;
    let _e132: vec4<f32> = b;
    powOut = pow(_e131, _e132);
    let _e135: vec4<f32> = a;
    let _e136: vec4<f32> = b;
    dotOut = dot(_e135, _e136);
    let _e139: vec4<f32> = a;
    let _e140: vec4<f32> = b;
    maxOut = max(_e139, _e140);
    let _e143: vec4<f32> = a;
    let _e144: vec4<f32> = b;
    minOut = min(_e143, _e144);
    let _e147: vec4<f32> = a;
    let _e148: vec4<f32> = b;
    reflectOut = reflect(_e147, _e148);
    let _e151: vec4<f32> = a;
    let _e153: vec4<f32> = b;
    crossOut = cross(_e151.xyz, _e153.xyz);
    let _e157: vec4<f32> = a;
    let _e158: vec4<f32> = b;
    outerProductOut = outerProduct(_e157, _e158);
    let _e161: vec4<f32> = a;
    let _e162: vec4<f32> = b;
    distanceOut = distance(_e161, _e162);
    let _e165: vec4<f32> = a;
    let _e166: vec4<f32> = b;
    stepOut = step(_e165, _e166);
    return;
}

[[stage(vertex)]]
fn main() {
    main1();
    return;
}
